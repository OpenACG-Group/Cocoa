CanvasKit: Serialize and Upload Drawing Operations
=================================================
序列化并上传绘制操作

TypeScript 模块 [CanvasKit](../typescript/core/CanvasKit.ts) 是绘制任务的主要承担者，
它导出了一系列类供用户调用进行绘图操作，也是 Cocoa 2D 绘图 API 的核心部分。
CanvasKit 可以将绘制操作序列化，写入到一系列内存缓冲区中，然后在合适的时候提交（Submit）它们，
Cocoa 原生绘图层会进行反序列化得到绘图指令，然后将它们送入 2D 渲染流水线的剩余阶段。

有关 2D 渲染流水线的更多内容，参阅 [Rendering Pipeline](./Rendering%20Pipeline.md).

## 1. Memory Buffer Management

CanvasKit 序列化的绘图指令数据需要存放到内存缓冲区中，我们可以直接申请固定长度的内存缓冲区，
然后往缓冲区写数据。但这样做的问题在于，由于进行绘图操作的是用户代码，
我们并不能事先知道绘图指令的总长度，即缓冲区可能在任何时候被填满。最直接的一个解决方案是，
每当缓冲区被填满时，将缓冲区内容提交给原生绘图层。此时有两种选择，一是复用原来的缓冲区，
这意味着在原生绘图层处理完提交的缓冲区内容之前，我们必须等待，
并且提交缓冲区片段意味着原生绘图层必须谨慎地处理前后的绘图状态，增加了设计的复杂度；
二是重新申请一个缓冲区，这会不可避免地导致内存分配带来的开销，尤其是对于需要快速刷新的渲染任务，
这种频繁内存分配与释放带来的开销更加明显。

以上两种方案都不可避免地带来开销，于是 CanvasKit 使用 `ProtoBufferPool` 类来管理缓冲区。
我们可以从 `ProtoBufferPool` 获得一个定长缓冲区，也可以将获得的缓冲区「归还」给它，
归还的缓冲区不会立刻被释放，而是存储到名为 `freelist` 的链表中。
当我们申请缓冲区时，`ProtoBufferPool` 优先从 `freelist` 查找大小符合要求的缓冲区，
如果有多个缓冲区大小符合要求，则会选中大小与申请大小的差值最小的缓冲区，称为最佳匹配；
如果连最佳匹配的差值都非常大，或者不存在大小符合要求的缓冲区，则分配新的内存缓冲区。

每个被 `ProtoBufferPool` 管理的缓冲区，都有一个名为 __空闲分配周期（Unused Allocation Cycle）__
的计数器，每当我们申请缓冲区时（即寻找最佳匹配时），
`freelist` 里除最佳匹配以外的所有缓冲区的空闲分配周期计数器都会 +1，
如果一个缓冲区成为最佳匹配，它的计数器将直接被设为 0，并且被移出 `freelist` 链表。
每次缓冲区申请结束时，我们将检查每个 `freelist` 中的缓冲区的空闲分配周期计数器，
如果达到每个设定的阈值，那么我们将把该缓冲区释放。

这一机制的意义在于，它实现了一种 __缓冲区回收机制__。设想一下，
如果某处代码申请了 16 字节的内存，然后马上就归还，而此后申请的缓冲区大小都远大于 16 字节，
那么这块 16 字节的内存留在 `freelist` 中，永远不会被使用到。当这种缓冲区逐渐积累，
内存就被严重浪费。因此我们用「空闲分配周期」这一概念去度量缓冲区未被使用的次数，
进而能够动态地释放长期未被复用的缓冲区，减小内存浪费。

## 2. GSK Intermediate Representation (GSKIR)
CanvasKit 序列化生成的二进制格式称为 __矢量绘图中间表示（GSKIR）__。

GSKIR 的基本单位是 __命令（Command）__，命令则可以进一步细分为
__指令（Instruction）__ 和 __注解（Annotation）__。

如果用自然语言来比喻的话，指令具有类似动词的性质，它会实际执行一些操作，
且这些操作的目标通常都直接指向目标画布或堆（我们会在下文介绍堆）上的对象；而注解的语义比指令要弱一些，
它辅助指令进行一些操作，例如，声明画布大小、指导解释器移动到下一个缓冲区、指导解释器结束解释过程等。
指令和注解的结构是一样的，都由 __谓词（Verb）__ 和 __操作数（Operands）__ 构成。
这方面读者可以类比汇编语言和其它基于字节码的虚拟机（如 JVM，Python 等）。

GSKIR 在被解释器运行时，始终存在一块随时可以被取用的内存空间，这块空间在进程虚拟地址空间中不一定连续，
因而分配在该内存块内的对象需要使用 __键（Key）__ 来访问，键常常是一个 32 位无符号整数。
这块内存空间便是 GSKIR VM 模型的 __堆（Heap）__。GSKIR 提供了一系列指令来在堆上创建、拷贝和销毁对象，
绘制过程中产生的很多中间对象都会被保存在堆上。明显，用于访问堆对象的键应当是合法的操作数。
需要注意的是，与 `malloc` 或 `new` 之类的函数（操作符）的语义不同，它们返回一个不可预测的地址，
而键是由用户来确定的，这类似于 C++ 中的「placement new」语法。实际上，在堆上创建对象时，
语义类似于「在内存中某位置处构造指定对象，然后将该对象映射到给定的键上」。

当然，一些操作数非常小（例如一个 float 浮点数），并且是需要立即被使用的字面量，那就没有必要把它们存在堆中。
这类操作数直接被编码进指令中，作为操作数而存在，它们被称为 __立即数（Immediate Operand）__。
实际上，用于访问堆对象的键本身也可以看作是一种立即数，毕竟键也以 32 位无符号整数的方式编码到指令中。

### 2.1. String Representation
GSKIR 的字符串表示非常简单，基本遵循汇编语言的格式。

__BNF 文法：__
```
translation_unit    ::= command | translation_unit '\n' command
command             ::= instruction | annotation
instruction         ::= INST operand_list
annotation          ::= '.'ANNON operand_list
operand_list        ::= operand | operand_list ',' operand
operand             ::= primitive_type '$'IDENTIFIER
                      | enum_type '$'IDENTIFIER
                      | heap_object_type '%'IDENTIFIER
primitive_type      ::= 'i8' | 'u8' | 'i16' | 'u16' | 'i32' | 'u32' | 'i64' | 'u64' | 'f32' | 'f64'
enum_type           ::= <omitted terminators...>
heap_object_type    ::= <omitted terminators...>
```

值得注意的是，所有的操作数都以 `$` 或 `%` 开头，且需要前缀一个类型标识符。
`$` 开头表示立即数，`%` 开头表示用于访问堆对象的键。对于这两种不同的情况，前缀的类型标识符有不同的语义：
* 对于立即数，类型标识符用于表明它本身的类型，例如 `f32 $3.14` 表明该操作数是一个 32 位浮点数，值为 `3.14`；
* 对于键，类型标识符用于表明该键指向的堆对象的类型，例如 `mat4x4 %1` 表明键 `1` 指向堆中的一个 4x4 矩阵对象。

`enum_type` 是一种枚举类型，这是一种特殊的立即数。枚举类型本质上是某种具有意义的常量，
而且每个枚举类型都具有一个确定的 underlying type，且这个 underlying type 属于 `primitive_type`。
例如，常量 `0x10` 没有意义，但是通过枚举类型，可以为常量赋予意义。当定义枚举 `BLENDMODE_SRC_OVER = 0x10` 时，
该常量就有意义了。这类似很多编程语言中提供的枚举类型，但实际上 GSKIR 中的枚举是一种「枚举映射」，要完全理解这一点，
需要我们讲到下文的 Renpy 代码生成，因此我们将在后文再对枚举类型做详细的解释。

下面是一个 GSKIR 字符串表示的实例：
```
.DrawBounds         f32 $800, f32 $600                      ; Size of current canvas
HeapCreateVector2   any %1, f32 $10, f32 $10                ; %1 = (10, 10)
HeapCreateVector2   any %2, f32 $100, f32 $100              ; %2 = (100, 100)
HeapCreateU32Array  any %3, u32 $4                          ; %3 = uint32[4]
HeapU32ArrayStore   u32array %3, u32 $0, u32 $0x0066cc00    ; %3[0] = 0x0066cc00
HeapU32ArrayStore   u32array %3, u32 $1, u32 $0x0066ccff    ; %3[1] = 0x0066ccff
HeapClone           any %3, any %4                          ; %4 = %3
HeapU32ArrayStore   u32array %4, u32 $2, u32 $0x002233ee    ; %4[2] = 0x002233ee
HeapFree            any %1
HeapFree            any %2
HeapFree            any %3
.CommandPoolEnd                             ; End of commands
```

这个实例没有任何实际的绘图操作，但是演示了很多重要的堆操作。如你所见，`HeapCreate*` 系列指令可以在堆上创建指定类型的对象，
第一个操作数就是要绑定到该对象的键。在这里它是 `any` 类型的，对于这一点我们可以理解为，
在这条指令执行之前，需要的对象还尚未被创建，因此它的类型是不确定的，我们用 `any` 来表示这种不确定。
而对象一旦被创建，其类型就确定了，所以在 `HeapU32ArrayStore` 一类的指令中，key 具有了 `u32array` 类型。
但是在 `HeapFree` 和 `HeapClone` 中，这些 key 又变为了 `any` 类型，这似乎令人感到困惑。
实际上，内存操作数（key 也可称为内存操作数）中类型的声明，是根据操作数所在的指令的需要来的。`HeapFree` 和
`HeapClone` 都不关心堆中的对象实际是什么类型，因此它们接受 `any` 类型的内存操作数。

### 2.2. Binary Representation
**直接二进制表示**

相比起字符串表示，GSKIR 的直接二进制表示非常朴素，为了节省空间，它舍弃了非常多的细节。

GSKIR 二进制表示即 GSKIR 字节码，一律采用小端字节序。如下是编码规则：
* 命令在缓冲区中线性排列，所有的命令都是定长的，没有变长命令；
* 对于每条命令，编码时先写入一个字（uint16），它的 0-11 位是 opcode，12-15 位是该指令包含的操作数数量；
* 接着，如果有操作数，则继续写入操作数，整数操作数直接写入对应字节数的数据（小端序），浮点数按照 IEEE754 标准编码写入；
* 内存操作数（键）作为 32 位无符号整数写入。

**直接二进制表示的空间问题**

二进制表示的最大问题在于空间占用。由于 GSKIR 是以字节为基本单位存储数据的，在写入数据时为了便于快速解析，
直接将未编码压缩的原始内存数据写入缓冲区。例如，32 位无符号整形数 12 被编码为：
`00 00 00 0c`，只有最后一个字节被使用，其余三个字节都被置为 0，造成了一定程度上的空间浪费。
要想完全使用这 4 个字节，编码的整数必须足够大，但问题在于 GSKIR 中几乎不会出现大整数，这就造成了更为严重的空间浪费。

32 位整数在 GSKIR 中常被用于编码内存操作数，用于绘图操作的数值常量（例如坐标等）大都是浮点数表示的。对于浮点数而言，
由于存在小数，对空间的利用率还是比较高的，例如，浮点数 3.14 被编码为 `c3 f5 48 40`，四个字节全部被使用了。

大部分绘图指令都会含有至少一个内存操作数用于指定操作对象（如 Path, Paint 等），且内存操作数一般不会是大整数，
因为需要保存在堆上的对象往往并不多。于是我们来尝试考察一下二进制表示带来的空间问题：
考虑 [Particle Simulator](../typescript/samples/particle_simulator.ts)，这是为了演示 Cocoa 2D 绘图 API
的粒子模拟示例程序，每个粒子都对应一个 `PathAddCircle` 指令，该指令定义在
[Renpy 文件中](../src/Glamor/Moe/moe-opcode-codegen.renpy)：
```
PathAddCircle   path %p, f32 $x, f32 $y, f32 $radius, u8 $ccwDir
```
编码操作码和操作数数量需要 2 字节，前 4 个参数分别需要 4 字节，最后一个需要 1 字节，总的来说，
完整编码这条指令需要 19 字节。由于每条 `PathAddCircle` 指令对应一个粒子，那么在平均粒子数为 1000
个/帧的模拟中，就需要 19000 字节（约 18.5KB）空间。


**快速压缩（Fast Compressed）的二进制表示**

为了解决直接二进制表示的空间占用问题，GSKIR 提供了经过快速压缩的二进制表示。
__快速压缩（Fast Compression）__ 意味着压缩算法是尽可能简单的，因为 GSKIR 需要在空间占用与解码翻译速度之间取舍。

_Basic Structure_
```
|  HEADER  |  OPCODE[]
| 
```


## 3. Serialization and Deserialization
TODO.
