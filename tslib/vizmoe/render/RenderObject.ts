/**
 * This file is part of Vizmoe.
 *
 * Vizmoe is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Vizmoe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Vizmoe. If not, see <https://www.gnu.org/licenses/>.
 */

import { Scene } from 'synthetic://glamor';
import { LinkedList } from '../../core/linked_list';
import { RenderTreeRecorder, LinearizationLogger, LinearizationContext } from './RenderTreeLinearization';
import { Vector2f } from '../graphics/Vector';

/**
 * Concepts:
 * 
 * - RenderTree:
 *     An intermediate representation between the WidgetTree
 *     and the LayerTree (Scene), generated by WidgetTree and
 *     is responsible to generate the corresponding LayerTree.
 * 
 * - RenderObject:
 *     A node in the RenderTree.
 * 
 * - Container Node:
 *     A RenderObject that can have children nodes.
 * 
 * - Generic Container Node:
 *     A container node that accepts any type of nodes to be its children.
 */

export enum RenderObjectType {
    /**
     * A compositor node is a generic container node.
     * It composites all the children's contents in the order they are
     * in the children list.
     */
    kCompositor,

    /**
     * A transformer node is a generic container node.
     * It makes a specific geometry transformation on its children nodes,
     * like scale, translate, rotate, etc.
     */
    kTransformer,

    /**
     * A painter node draws contents on the canvas.
     */
    kPainter,

    /**
     * A static texture node draws a specific texture on the canvas,
     * and the texture will not change (but different transformations
     * can be applied by transformer nodes).
     */
    kStaticTexture,

    kVideoTexture
}

export class FlattenContext {
    public readonly recorder: RenderTreeRecorder;

    constructor() {
        this.recorder = new RenderTreeRecorder();
    }
}

let g_object_id_counter = 1;

export abstract class RenderObject {
    protected parent_: RenderObject | null;
    protected children_: LinkedList<RenderObject>;
    protected node_type_: RenderObjectType;
    private readonly unique_node_id_: number;

    public static Generate(root: RenderObject, viewportSize: Vector2f,
                           context: LinearizationContext, logger?: LinearizationLogger): Scene
    {
        const flattenContext = new FlattenContext();
        root.flatten(flattenContext);
        return flattenContext.recorder.generate(viewportSize, context, logger);
    }

    protected constructor(parent: RenderObject, children: LinkedList<RenderObject>, type: RenderObjectType) {
        this.parent_ = parent;
        this.children_ = children;
        this.node_type_ = type;
        if (parent != null) {
            parent.children_.push(this);
        }
        this.unique_node_id_ = g_object_id_counter++;
    }

    public get childrenList(): LinkedList<RenderObject> {
        return this.children_;
    }

    /* Internal API */
    public _privSetParent(parent: RenderObject): void {
        this.parent_ = parent;
    }

    public appendChild(child: RenderObject): void {
        child.parent_ = this;
        this.children_.push(child);
    }

    public removeChild(child: RenderObject): void {
        if (!this.children_.removeIf(node => (node == child))) {
            throw Error('Child node does not exist in the children list');
        }
        child.parent_ = null;
    }

    public get nodeType(): RenderObjectType {
        return this.node_type_;
    }

    public get uniqueNodeId(): number {
        return this.unique_node_id_;
    }

    public abstract flatten(context: FlattenContext): void;
}
